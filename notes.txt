



— a thread for detecting the marker
This thread continoisly detects the marker, and updates self.current_rect

— a thread for firing selection events: 
This thread continoisly queries scene physical objects and annotations for colliding with the center point of self.current_rect. If a collision is detected, the timestamp is recorded. If after 3 seconds the collision is still active, a SelectionEvent is fired, with list of annotations and physical objects that are selected. 

— An event manager that registers listeners for different event types and fires the events. Firing an event means calling all listeners for that event with the given event params. 

— A selection service that is listener for SelectionEvents. When event is called, the on_select() event of all parameter annotations and physical objects is called (in a separate thread?)


=======================================================
[See below.]

* We don't need object detection when designing the scene.
* The author designs the scene using the template images of the physical objects.
* During the learning session, we use object detection and work with real physical objects.

* To add a physical object to the scene, the user has to drag and drop it to the scene.
* To remove a physical object from scene, the user uses the delete tool

* All annotations have their position in relationship to either scene or the physical object the are attached to.
* All positions are absolute in image coordinates. 



=======================================================

[*** OBSOLETE ***, see above. Read carefully though. Here maybe still important requirements.]

* To add a physical object to the scene, the user has to drag and drop it to the scene.

* To remove a physical object from scene, the user uses the delete tool

* If a physical object of the scene is present on the table, its image is not shown, but its bounding box is shown.

* If a physical object of the scene is not present on the table, its image is shown.

* we don’t support multiple instances a physical object, because
 a) the use case become too complicated,
 b) there is no way to distinguish visually between two instances of the same object,
 c) the use cases are limited



=====================================================================

[*** OBSOLETE ***, see above. Read carefully though. Here maybe still important requirements.]

Objects can be added in two ways to the scene: 
	a) 
	By drag-n-drop from the object list (in that case the template image of the object is shown on the scene). 
	You can have multiple instances of the same object at the same time on the scene. Those instances are either a template image or the real object.

	b) 
	By putting them on the table. 


The physical objects view shows the list of the object classes that can be added to the scene. If an object class is added to the scene (one or multiples instances of it), then that object class is highlighted in the physical objects view. 

To remove a physical object instance from the scene the user either remove it from the tabletop (if it is on the table) or uses the delete tool to remove it.

The attach to combo box shows a list of instance of the objects available on the scene. 

When a physical object is removed form the scene the annotations attached to it remain in the scene, but are not attached to it. If the user want to also remove those annotations, he uses the delete tool. 




===================================================



Let each annotation draw itself. 

Let each annotation has its own select method for authoring time and select method for runtime. 


The SceneView widget has an active annotation tool. 
The SceneView widget forwards the mouse down, mouse mouse, mouse release events to its active annotation tool. 





==================================================

[DISCARDED in favor of annotation tools and fast implementation; It is too complex]

A scene consists of SceneNodes. 

The scene's root node is at the (0,0) position.

Each scene node corresponds to an object or an annotation.

Each scene node can have children scene nodes.

All children of a scene node have their positions relative to its position. 

We deliver the OpenCV frame with drawings for all scene nodes

Each scene node has a paint method.

When that paint method is called it draws itself on the given OpenCV frame, and calls recursively the paint method on all its children. 


=================================================

