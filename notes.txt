
Defining Domain learning exercises: 

* All is possible with current setup. No need for separate UI. 
* Two kind of exercises: Multiple choice, and choose or select physical object
* For multiple choice, we show the text of question, and the different options. Each option has an associated checkbox. The author can define actions that should happen whenever a check box is selected.
 





==============================


* when defining an action, the user first selects the scene. If the action is ShowScene  then that scene is the target scene. If the action is an annotation related action, then only annotations on the selected scene can be selected as target of the action. The name of the scene (which is unique) is also saved in the action for sanity check. 

* The SelectButtonAnnotation’s OnSelect combobox also shows only actions defined for the current scene + actions related to scene transition (show scene, next scene, previous scene)

* Similar case for events. When defining an event (like SelectionEvent or ObjectAppeared, ...) the user must first select the scene. And the user can only select targets from this scene. 

* Actually, defining actions and events is only a function for the current scene. The dialogs for defining actions, events, and EventActionRules are opened from UI and initialized with the current scene. Except scene related actions and events, the user can only select the  objects an annotations of the current scene as the target. 

* The user first defines Events. Then he defines actions. Then he defines EventActionRules. 


=====================

* [don't need it] Compare Scene Action: has the current scene, and another selected scene as argument. Has two action attributes for both cases “identical” and “different”. Compares both scenes, and performs the identical action in case both scenes are equal, or different action, if the scenes are different. For example the identical action could be “show positive feedback annotation”, or the different action could be “show negative feedback scene” or “highlight the differences action”

* we definitely need the composite action for composition of actions: two sequence operators AND and THEN. The AND operator performs the actions in parallel. The THEN operator performs them in after one another. (Performing sequentially: a for loop on the actions with time.sleep(1) in between; Performing parallel, a for loop that starts a thread for each action)

* Wait Action (waits for the given time) 

* [don't need it] Highlight Scene Differences Action: takes scenes, and highlights their differences. 


=====================
ALL DONE

* I make a fixed sequential order of scenes [1, 2, 3]

* I add a BackSceneAction, that simply shows whatever scene that was showing before current_scene. The ScenesModel, keeps a pointer to previous scene, and whenever its back() method is called it shows that scene and clears the pointer (if current_scene == back_scene: back_scene = None)

* The next scene action and previous scene action go back and forth in the fixed sequential scene navigation

* if we are at the first scene, the previous scene action does not do anything
* If we are at the last scene, the next scene action does not do anything. 


=========================================================


— a thread for detecting the marker
This thread continoisly detects the marker, and updates self.current_rect

— a thread for firing selection events: 
This thread continoisly queries scene physical objects and annotations for colliding with the center point of self.current_rect. If a collision is detected, the timestamp is recorded. If after 3 seconds the collision is still active, a SelectionEvent is fired, with list of annotations and physical objects that are selected. 

— An event manager that registers listeners for different event types and fires the events. Firing an event means calling all listeners for that event with the given event params. 

— A selection service that is listener for SelectionEvents. When event is called, the on_select() event of all parameter annotations and physical objects is called (in a separate thread?)


=======================================================
[See below.]

* We don't need object detection when designing the scene.
* The author designs the scene using the template images of the physical objects.
* During the learning session, we use object detection and work with real physical objects.

* To add a physical object to the scene, the user has to drag and drop it to the scene.
* To remove a physical object from scene, the user uses the delete tool

* All annotations have their position in relationship to either scene or the physical object the are attached to.
* All positions are absolute in image coordinates. 



=======================================================

[*** OBSOLETE ***, see above. Read carefully though. Here maybe still important requirements.]

* To add a physical object to the scene, the user has to drag and drop it to the scene.

* To remove a physical object from scene, the user uses the delete tool

* If a physical object of the scene is present on the table, its image is not shown, but its bounding box is shown.

* If a physical object of the scene is not present on the table, its image is shown.

* we don’t support multiple instances a physical object, because
 a) the use case become too complicated,
 b) there is no way to distinguish visually between two instances of the same object,
 c) the use cases are limited



=====================================================================

[*** OBSOLETE ***, see above. Read carefully though. Here maybe still important requirements.]

Objects can be added in two ways to the scene: 
	a) 
	By drag-n-drop from the object list (in that case the template image of the object is shown on the scene). 
	You can have multiple instances of the same object at the same time on the scene. Those instances are either a template image or the real object.

	b) 
	By putting them on the table. 


The physical objects view shows the list of the object classes that can be added to the scene. If an object class is added to the scene (one or multiples instances of it), then that object class is highlighted in the physical objects view. 

To remove a physical object instance from the scene the user either remove it from the tabletop (if it is on the table) or uses the delete tool to remove it.

The attach to combo box shows a list of instance of the objects available on the scene. 

When a physical object is removed form the scene the annotations attached to it remain in the scene, but are not attached to it. If the user want to also remove those annotations, he uses the delete tool. 




===================================================



Let each annotation draw itself. 

Let each annotation has its own select method for authoring time and select method for runtime. 


The SceneView widget has an active annotation tool. 
The SceneView widget forwards the mouse down, mouse mouse, mouse release events to its active annotation tool. 





==================================================

[DISCARDED in favor of annotation tools and fast implementation; It is too complex]

A scene consists of SceneNodes. 

The scene's root node is at the (0,0) position.

Each scene node corresponds to an object or an annotation.

Each scene node can have children scene nodes.

All children of a scene node have their positions relative to its position. 

We deliver the OpenCV frame with drawings for all scene nodes

Each scene node has a paint method.

When that paint method is called it draws itself on the given OpenCV frame, and calls recursively the paint method on all its children. 


=================================================

